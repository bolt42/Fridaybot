import { ref, get, set } from "firebase/database";
import { rtdb } from "../firebaseConfig.js"; // adjust path

// ====================== ENV CONFIG ======================
const TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const WEBAPP_URL = process.env.WEBAPP_URL || "https://your-app.vercel.app";
const ADMIN_IDS = (process.env.ADMIN_IDS || "")
  .split(",")
  .map((id) => parseInt(id.trim()))
  .filter(Boolean);

// ---- In-memory data (replace with DB for production) ----
const users = new Map();
const rooms = new Map();
const transactions = new Map();
const withdrawalRequests = new Map();

// ====================== UTILS ======================
async function telegram(method, payload) {
  const url = `https://api.telegram.org/bot${TOKEN}/${method}`;
  return fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });
}

async function sendMessage(chatId, text, extra = {}) {
  return telegram("sendMessage", { chat_id: chatId, text, ...extra });
}

async function registerUserToFirebase(user) {
  try {
    const userRef = ref(rtdb, "users/" + user.id);
    const snapshot = await get(userRef);

    if (!snapshot.exists()) {
      const now = new Date().toISOString();
      const newUser = {
        telegramId: user.id.toString(),
        username: user.username || `user_${user.id}`,
        balance: 50,
        gamesPlayed: 0,
        gamesWon: 0,
        totalWinnings: 0,
        language: user.language_code || "en",
        createdAt: now,
        updatedAt: now,
      };
      await set(userRef, newUser);
      console.log("‚úÖ User registered:", newUser);
    } else {
      console.log("üîπ User already exists in RTDB");
    }
  } catch (err) {
    console.error("‚ùå Error registering user:", err);
  }
}

// ====================== COMMAND HANDLERS ======================
async function handleStart(message) {
  const chatId = message.chat.id;
  const user = message.from;

  await registerUserToFirebase(user);

  const welcomeText = `
üéØ Welcome to Friday Bingo! üéØ

Available commands:
/playgame - Launch the bingo mini app
/deposit - Add funds to your account
/withdraw - Withdraw your winnings

Let's play some bingo! üéä
  `;
  await sendMessage(chatId, welcomeText);
}

async function handlePlayGame(message) {
  const chatId = message.chat.id;
  const user = message.from;

  await registerUserToFirebase(user);

  if (!users.has(user.id)) {
    users.set(user.id, {
      id: user.id,
      username: user.username || `user_${user.id}`,
      balance: 50,
      createdAt: new Date(),
    });
  }

  const keyboard = {
    inline_keyboard: [
      [
        {
          text: "üéÆ Play Friday Bingo",
          web_app: { url: WEBAPP_URL },
        },
      ],
    ],
  };

  await sendMessage(chatId, "üéØ Ready to play Friday Bingo? Tap the button below!", {
    reply_markup: keyboard,
  });
}

// ====================== USER COMMANDS ======================
bot.onText(/\/deposit/, (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  if (!users.has(userId)) {
    sendMessage(chatId, "·ä•·â£·ä≠·ãé ·â†·àò·åÄ·àò·à™·ã´ /playgame ·ã≠·â∞·ã≠·â°·ç¢");
    return;
  }

  const keyboard = {
    inline_keyboard: [
      [{ text: "üì± CBE Mobile Banking", callback_data: "deposit_cbe" }],
      [{ text: "üí≥ Telebirr", callback_data: "deposit_telebirr" }],
    ],
  };

  sendMessage(chatId, "·ã®·ä≠·çç·ã´ ·àò·äï·åà·ã±·äï ·ã≠·àù·à®·å°:", { reply_markup: keyboard });
});

bot.onText(/\/withdraw/, (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  if (!users.has(userId)) {
    sendMessage(chatId, "·ä•·â£·ä≠·ãé ·â†·àò·åÄ·àò·à™·ã´ /playgame ·ã≠·â∞·ã≠·â°·ç¢");
    return;
  }

  const user = users.get(userId);
  sendMessage(
    chatId,
    `üí∞ ·ã®·ä†·àÅ·äï ·àÇ·à≥·â•·ãé: ${user.balance} ·â•·à≠\n\n·ã®·àö·ãà·å£·ãç·äï ·àò·å†·äï ·ã≠·àã·ä© (·àù·à≥·àå: 100):`
  );

  bot.once("message", (amountMsg) => {
    const amount = parseFloat(amountMsg.text);

    if (isNaN(amount) || amount <= 0) {
      sendMessage(chatId, "‚ùå ·âµ·ä≠·ä≠·àà·äõ ·àò·å†·äï ·ã´·àµ·åà·â°·ç¢");
      return;
    }

    if (amount > user.balance) {
      sendMessage(chatId, "‚ùå ·â†·âÇ ·àÇ·à≥·â• ·ã®·àà·ãé·âµ·àù·ç¢");
      return;
    }

    sendMessage(
      chatId,
      "·ã®·àò·ãç·å´ ·ä†·ä´·ãç·äï·âµ ·àò·à®·åÉ ·ã≠·àã·ä© (·ã®·â£·äï·ä≠ ·àÇ·à≥·â• ·ãà·ã≠·àù ·ã®·â¥·àå·â•·à≠ ·âÅ·å•·à≠):"
    );

    bot.once("message", (accountMsg) => {
      const account = accountMsg.text;
      const requestId = `${userId}_${Date.now()}`;

      withdrawalRequests.set(requestId, {
        id: requestId,
        userId,
        amount,
        account,
        status: "pending",
        createdAt: new Date(),
      });

      user.balance -= amount;
      users.set(userId, user);

      sendMessage(
        chatId,
        "‚è≥ ·ã®·àõ·ãç·å´ ·å•·ã´·âÑ·ãé ·â∞·âÄ·â†·àà·ç¢ ·ä•·â£·ä≠·ãé ·ã≠·å†·â•·âÅ·ç£ ·åç·â•·ã≠·â± ·â†·àõ·àµ·ä¨·ãµ ·àã·ã≠ ·äê·ãç·ç¢"
      );

      ADMIN_IDS.forEach((adminId) => {
        if (adminId) {
          const keyboard = {
            inline_keyboard: [
              [
                {
                  text: "‚úÖ ·ä≠·çç·ã´ ·â∞·çà·å∏·àò",
                  callback_data: `complete_withdrawal_${requestId}`,
                },
              ],
            ],
          };

          sendMessage(
            adminId,
            `üí∞ ·ã®·àõ·ãç·å´ ·å•·ã´·âÑ:\n\nüë§ ·â∞·å†·âÉ·àö: @${
              user.username || userId
            }\nüíµ ·àò·å†·äï: ${amount} ·â•·à≠\nüè¶ ·ä†·ä´·ãç·äï·âµ: ${account}\nüïê ·åä·ãú: ${new Date().toLocaleString()}`,
            { reply_markup: keyboard }
          );
        }
      });
    });
  });
});

// ====================== CALLBACK QUERIES ======================
bot.on("callback_query", (callbackQuery) => {
  const chatId = callbackQuery.message.chat.id;
  const userId = callbackQuery.from.id;
  const data = callbackQuery.data;

  if (data === "deposit_cbe") {
    sendMessage(
      chatId,
      'üì± CBE Mobile Banking SMS ·ã∞·à®·à∞·äû·äï ·ã≠·àã·ä©:\n\n·àù·à≥·àå: "CBE: Transaction successful. Amount: 100.00 ETB. Ref: TXN123456789. Balance: 500.00 ETB. Time: 15:30 12/01/2024"'
    );

    bot.once("message", async (smsMsg) => {
      const smsText = smsMsg.text;
      const transactionDetails = await parseCBESMS(smsText);

      if (transactionDetails) {
        await processDeposit(userId, transactionDetails, chatId);
      } else {
        sendMessage(chatId, "‚ùå ·âµ·ä≠·ä≠·àà·äõ CBE SMS ·ã´·àµ·åà·â°·ç¢");
      }
    });
  } else if (data === "deposit_telebirr") {
    sendMessage(
      chatId,
      'üí≥ Telebirr SMS ·ã∞·à®·à∞·äû·äï ·ãà·ã≠·àù ·ã®·ãµ·à≠ ·ä†·åà·äì·äô·äï ·ã≠·àã·ä©:\n\n·àù·à≥·àå: "https://telebirr.com/receipt/ABC123" ·ãà·ã≠·àù SMS ·ã∞·à®·à∞·äù'
    );

    bot.once("message", async (receiptMsg) => {
      const receiptText = receiptMsg.text;
      let transactionDetails;

      if (receiptText.startsWith("http")) {
        transactionDetails = await scrapeTelebirrReceipt(receiptText);
      } else {
        transactionDetails = await parseTelebirrSMS(receiptText);
      }

      if (transactionDetails) {
        await processDeposit(userId, transactionDetails, chatId);
      } else {
        sendMessage(chatId, "‚ùå ·âµ·ä≠·ä≠·àà·äõ Telebirr ·ã∞·à®·à∞·äù ·ã´·àµ·åà·â°·ç¢");
      }
    });
  } else if (data.startsWith("complete_withdrawal_")) {
    const requestId = data.replace("complete_withdrawal_", "");
    const request = withdrawalRequests.get(requestId);

    if (request && request.status === "pending") {
      request.status = "completed";
      withdrawalRequests.set(requestId, request);

      sendMessage(
        request.userId,
        `‚úÖ ·ã®·àõ·ãç·å´ ·å•·ã´·âÑ·ãé ·â∞·çà·åΩ·àü·àç!\n\nüíµ ·àò·å†·äï: ${request.amount} ·â•·à≠\nüè¶ ·ä†·ä´·ãç·äï·âµ: ${request.account}`
      );

      sendMessage(chatId, `‚úÖ ·ã®·àõ·ãç·å´ ·å•·ã´·âÑ ${requestId} ·â∞·çà·åΩ·àü·àç·ç¢`);
    }
  }

  bot.answerCallbackQuery(callbackQuery.id);
});

// ====================== ADMIN COMMANDS ======================
bot.onText(/\/admin_create_room/, (msg) => {
  const userId = msg.from.id;
  if (!ADMIN_IDS.includes(userId)) {
    sendMessage(msg.chat.id, "‚ùå You are not authorized.");
    return;
  }

  sendMessage(
    msg.chat.id,
    "Send room details in format:\nRoomName,BetAmount,MaxPlayers"
  );

  bot.once("message", (roomMsg) => {
    const [name, betAmount, maxPlayers] = roomMsg.text.split(",");

    if (name && betAmount && maxPlayers) {
      const roomId = `room_${Date.now()}`;
      rooms.set(roomId, {
        id: roomId,
        name: name.trim(),
        betAmount: parseFloat(betAmount.trim()),
        maxPlayers: parseInt(maxPlayers.trim()),
        currentPlayers: 0,
        gameStatus: "waiting",
        isDemoRoom: false,
        createdBy: userId,
      });

      sendMessage(msg.chat.id, `‚úÖ Room "${name}" created successfully!`);
    } else {
      sendMessage(msg.chat.id, "‚ùå Invalid format. Try again.");
    }
  });
});

bot.onText(/\/admin_balance (.+) (.+)/, (msg, match) => {
  const userId = msg.from.id;
  if (!ADMIN_IDS.includes(userId)) {
    sendMessage(msg.chat.id, "‚ùå You are not authorized.");
    return;
  }

  const username = match[1];
  const amount = parseFloat(match[2]);

  const targetUser = Array.from(users.values()).find(
    (u) => u.username === username
  );

  if (targetUser) {
    targetUser.balance += amount;
    users.set(targetUser.id, targetUser);

    sendMessage(
      msg.chat.id,
      `‚úÖ Balance updated for @${username}:\nNew balance: ${targetUser.balance} ETB`
    );

    sendMessage(
      targetUser.id,
      `üí∞ Your balance has been updated!\nChange: ${
        amount > 0 ? "+" : ""
      }${amount} ETB\nNew balance: ${targetUser.balance} ETB`
    );
  } else {
    sendMessage(msg.chat.id, `‚ùå User @${username} not found.`);
  }
});

// ====================== UTILS ======================
async function processDeposit(userId, transactionDetails, chatId) {
  const user = users.get(userId);
  if (!user) {
    sendMessage(chatId, "‚ùå ·â∞·å†·âÉ·àö ·ä†·àç·â∞·åà·äò·àù·ç¢");
    return;
  }

  transactions.set(transactionDetails.transactionId, {
    ...transactionDetails,
    userId,
    status: "completed",
  });

  user.balance += transactionDetails.amount;
  users.set(userId, user);

  sendMessage(
    chatId,
    `‚úÖ ·ä≠·çç·ã´·ãé ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·âÄ·â•·àè·àç!\n\nüíµ ·ã®·åà·â£ ·àò·å†·äï: ${
      transactionDetails.amount
    } ·â•·à≠\nüè¶ ·ã®·ä≠·çç·ã´ ·àò·äï·åà·ãµ: ${
      transactionDetails.method
    }\nüí∞ ·ä†·ã≤·àµ ·àÇ·à≥·â•: ${user.balance} ·â•·à≠\nüì± ·ã®·åç·â•·ã≠·âµ ·âÅ·å•·à≠: ${
      transactionDetails.transactionId
    }`
  );
}


// ====================== WEBHOOK HANDLER ======================
export default async function handler(req, res) {
  console.log("üöÄ Webhook hit!", req.method);

  // CORS headers
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type");

  if (req.method === "OPTIONS") return res.status(200).end();
  if (req.method === "GET")
    return res.status(200).json({ status: "Bot is running", time: Date.now() });

  if (req.method === "POST") {
    try {
      const update = req.body;
      console.log("üì© Telegram update:", JSON.stringify(update, null, 2));

      // Always ACK immediately so Telegram doesn‚Äôt retry
      res.status(200).json({ ok: true });

      if (update.message) {
        const text = update.message.text;
        if (text === "/start") await handleStart(update.message);
        else if (text === "/playgame") await handlePlayGame(update.message);
        else if (text === "/deposit") {
          await sendMessage(update.message.chat.id, "üëâ Deposit flow not yet refactored.");
        }
        else if (text === "/withdraw") {
          await sendMessage(update.message.chat.id, "üëâ Withdraw flow not yet refactored.");
        }
        else {
          await sendMessage(update.message.chat.id, `You said: ${text}`);
        }
      }

      if (update.callback_query) {
        await sendMessage(update.callback_query.message.chat.id, "Callback received!");
      }
    } catch (err) {
      console.error("‚ùå Error in handler:", err);
      return res.status(200).json({ ok: true }); // prevent Telegram retries
    }
    return;
  }

  res.status(405).json({ error: "Method not allowed" });
}
